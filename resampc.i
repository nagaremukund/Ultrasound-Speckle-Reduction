










/* Resampling along the column (Type 1 and 2)
 *
 * Created by: Minh N. Do, March 2000
 */ 


/*
 * @(#)mex.h    generated by: makeheader 4.21  Tue Jul 26 22:40:19 2005
 *
 *		built from:	../../src/include/copyright.h
 *				../../src/include/pragma_interface.h
 *				mex_typedefs.h
 *				./fmexapi.cpp
 *				./fmexapiv5.cpp
 *				./globals.cpp
 *				./mexapi.cpp
 *				./mexapiv4.cpp
 *				./mexapiv5.cpp
 *				./mexcbk.cpp
 *				./mexdispatch.cpp
 *				./mexintrf.cpp
 *				mexdbg.h
 */





/*
 * Copyright 1984-2003 The MathWorks, Inc.
 * All Rights Reserved.
 */



/* Copyright 2003-2004 The MathWorks, Inc. */

/*
 * Prevent g++ from making copies of vtable and typeinfo data
 * in every compilation unit.  By allowing for only one, we can
 * save space and prevent some situations where the linker fails
 * to coalesce them properly into a single entry.
 *
 * References:
 *    http://gcc.gnu.org/onlinedocs/gcc/Vague-Linkage.html#Vague%20Linkage
 *    http://gcc.gnu.org/onlinedocs/gcc/C---Interface.html
 */





/* Copyright 1999-2001 The MathWorks, Inc. */

/* $Revision: 1.7.4.1 $ */



# 56 "C:\MATLAB71\extern\include\mex.h"
typedef struct impl_info_tag *MEX_impl_info;


/*
 * @(#)matrix.h    generated by: makeheader 4.21  Tue Jul 26 18:26:13 2005
 *
 *		built from:	../../src/include/copyright.h
 *				../../src/include/pragma_interface.h
 *				./alloccbk.cpp
 *				./alloclst.cpp
 *				./array.cpp
 *				./array2.cpp
 *				./arraycbk.cpp
 *				./arraycpy.cpp
 *				./assignmt.cpp
 *				./bytestr.cpp
 *				./catenate.cpp
 *				./cellindex.cpp
 *				./checkdim.cpp
 *				./conversions.cpp
 *				./end.cpp
 *				./errmsg.cpp
 *				./error.cpp
 *				./fmxapi.cpp
 *				./fmxapiv5.cpp
 *				./funhdl.cpp
 *				./ieee_wrap.cpp
 *				./indexcpy.cpp
 *				./iocbk.cpp
 *				./marshal.cpp
 *				./mcat.cpp
 *				./mxapiv4.cpp
 *				./mxapiv5.cpp
 *				./mxassert.cpp
 *				./mxequal.cpp
 *				./mxutil.cpp
 *				./nameindex.cpp
 *				./nargchk.cpp
 *				./numconv.cpp
 *				./opaque.cpp
 *				./permute.cpp
 *				./populate.cpp
 *				./referenc.cpp
 *				./resize.cpp
 *				./rndcolon.cpp
 *				./scopemgr.cpp
 *				./spassex.cpp
 *				./sprefex.cpp
 *				./strconv.cpp
 *				./subserror.cpp
 *				./transpose.cpp
 *				./txtcmp.cpp
 *				./undoc.cpp
 *				./warning.cpp
 *				./zbuffer.cpp
 *				mxdbg.h
 */





/*
 * Copyright 1984-2003 The MathWorks, Inc.
 * All Rights Reserved.
 */



/* Copyright 2003-2004 The MathWorks, Inc. */

/*
 * Prevent g++ from making copies of vtable and typeinfo data
 * in every compilation unit.  By allowing for only one, we can
 * save space and prevent some situations where the linker fails
 * to coalesce them properly into a single entry.
 *
 * References:
 *    http://gcc.gnu.org/onlinedocs/gcc/Vague-Linkage.html#Vague%20Linkage
 *    http://gcc.gnu.org/onlinedocs/gcc/C---Interface.html
 */








/*
 * allocate memory, notifying registered listener
 */

# 96 "C:\MATLAB71\extern\include\matrix.h"
extern void *mxMalloc(
    size_t	n		/* number of bytes */
    );



/*
 * allocate cleared memory, notifying registered listener.
 */

# 109 "C:\MATLAB71\extern\include\matrix.h"
extern void *mxCalloc(
    size_t	n,	/* number of objects */
    size_t	size	/* size of objects */
    );



/*
 * free memory, notifying registered listener.
 */

# 123 "C:\MATLAB71\extern\include\matrix.h"
extern void mxFree(void *ptr);	/* pointer to memory to be freed */



/*
 * reallocate memory, notifying registered listener.
 */

# 134 "C:\MATLAB71\extern\include\matrix.h"
extern void *mxRealloc(void *ptr, size_t size);





/*
 * Incomplete definition of mxArray
 */

# 144 "C:\MATLAB71\extern\include\matrix.h"
typedef struct mxArray_tag mxArray;

/* !defined(mxArray_DEFINED) */



/*
 * @(#)tmwtypes.h    generated by: makeheader 4.21  Tue Jul 26 23:02:50 2005
 *
 *		built from:	../../src/include/copyright.h
 *				../../src/include/tmwtypes.h
 */





/*
 * Copyright 1984-2003 The MathWorks, Inc.
 * All Rights Reserved.
 */



/* Copyright 1995-2004 The MathWorks, Inc. */



/*
 * File    : tmwtypes.h
 * Abstract:
 *      Data types for use with MATLAB/SIMULINK and the Real-Time Workshop.
 *
 *      When compiling stand-alone model code, data types can be overridden
 *      via compiler switches.
 *
 *      Define NO_FLOATS to eliminate reference to real_T, etc.
 */

/* $Revision: 1.45.4.8 $ */








/*NO_FLOATS*/









/*NO_FLOATS*/

/*
 *      The following data types cannot be overridden when building MEX files.
 */








/*
 * The uchar_T, ushort_T and ulong_T types are needed for compilers which do 
 * not allow defines to be specified, at the command line, with spaces in them.
 */


# 79 "C:\MATLAB71\extern\include\tmwtypes.h"
typedef unsigned char  uchar_T;
typedef unsigned short ushort_T;
typedef unsigned long  ulong_T;



/*=======================================================================*
 * Fixed width word size data types:                                     *
 *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *
 *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *
 *   real32_T, real64_T           - 32 and 64 bit floating point numbers *
 *=======================================================================*/

/* When used with Real Time Workshop generated code, this
 * header file can be used with a variety of compilers.
 *
 * The compiler could be for an 8 bit embedded processor that
 * only had 8 bits per integer and 16 bits per long.
 * In that example, a 32 bit integer size is not even available.
 * This header file should be robust to that.   
 *
 * For the case of an 8 bit processor, the preprocessor
 * may be limited to 16 bit math like its target.  That limitation 
 * would mean that 32 bit comparisons can't be done accurately.  
 * To increase robustness to this, comparisons are done against
 * smaller values first.  An inaccurate 32 bit comparison isn't
 * attempted if the 16 bit comparison has already succeeded.
 *
 * Limitations on preprocessor math can also be stricter than
 * for the target.  There are known cases where a compiler
 * targeting processors with 64 bit longs can't do accurate
 * preprocessor comparisons on more than 32 bits.  
 */

/* Determine the number of bits for int, long, short, and char.
 * If one fails to be determined, set the number of bits to -1
 */
































/* It is common for one or more of the integer types
 * to be the same size.  For example, on many embedded
 * processors, both shorts and ints are 16 bits.  On
 * processors used for workstations, it is quite common
 * for both int and long to be 32 bits.  
 *   When there is more than one choice for typdef'ing
 * a portable type like int16_T or uint32_T, in
 * concept, it should not matter which choice is made.
 * However, some style guides and some code checking
 * tools do identify and complain about seemingly
 * irrelevant differences.  For example, a code
 * checking tool may complain about an implicit
 * conversion from int to short even though both
 * are 16 bits.  To reduce these types of
 * complaints, it is best to make int the
 * preferred choice when more than one is available.
 */



































/* The following is used to emulate smaller integer types when only
 * larger types are available.  For example, compilers for TI C3x/C4x DSPs 
 * define char and short to be 32 bits, so 8 and 16 bits are not directly
 * available.  This target is commonly used with RTW rapid prototyping.
 * Other DSPs define char to be 16 bits, so 8 bits is not directly 
 * available.
 */






































/* NO_FLOATS*/

/*=======================================================================*
 * Fixed width word size data types:                                     *
 *   int64_T                      - signed 64 bit integers               *
 *   uint64_T                     - unsigned 64 bit integers             *
 *=======================================================================*/























/*===========================================================================*
 * General or logical data types where the word size is not guaranteed.      *
 *  real_T     - possible settings include real32_T or real64_T              *
 *  time_T     - possible settings include real64_T or uint32_T              *
 *  boolean_T                                                                *
 *  char_T                                                                   *
 *  int_T                                                                    *
 *  uint_T                                                                   *
 *  byte_T                                                                   *
 *===========================================================================*/















/* NO_FLOATS */







# 486 "C:\MATLAB71\extern\include\tmwtypes.h"
typedef unsigned int  boolean_T;






# 492 "C:\MATLAB71\extern\include\tmwtypes.h"
typedef char  char_T;






# 498 "C:\MATLAB71\extern\include\tmwtypes.h"
typedef int  int_T;






# 504 "C:\MATLAB71\extern\include\tmwtypes.h"
typedef unsigned  uint_T;






# 510 "C:\MATLAB71\extern\include\tmwtypes.h"
typedef unsigned char  byte_T;


/*===========================================================================*
 * Define Complex Structures                                                 *
 *===========================================================================*/














/* NO_FLOATS */

























/*=======================================================================*
 * Min and Max:                                                          *
 *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *
 *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *
 *=======================================================================*/



































# 682 "C:\MATLAB71\extern\include\tmwtypes.h"
typedef boolean_T bool;








/* _bool_T */

/* !__cplusplus */

/* 
 * This software assumes that the code is being compiled on a target using a 
 * 2's complement representation for signed integer values.
 */





/*
 * Maximum length of a MATLAB identifier (function/variable/model)
 * including the null-termination character.
 */


/* __TMWTYPES__ */

/* tmwtypes_h */



# 151 "C:\MATLAB71\extern\include\matrix.h"
typedef void(*mxFunctionPtr)(int nlhs, mxArray *plhs[], int nrhs, mxArray *prhs[]);






# 156 "C:\MATLAB71\extern\include\matrix.h"
typedef bool     mxLogical;




# 165 "C:\MATLAB71\extern\include\matrix.h"
    /* Default is schizophrenic rep when Unicode is NOT enabled. */
    typedef uint16_T mxChar;


/*
 * Flipped the position of mxLOGICAL_CLASS and mxOBJECT_CLASS
 * to make sure that mxOBJECT_CLASS is last in the list.
 */

# 173 "C:\MATLAB71\extern\include\matrix.h"
typedef enum {
	mxUNKNOWN_CLASS = 0,
	mxCELL_CLASS,
	mxSTRUCT_CLASS,
	mxLOGICAL_CLASS,
	mxCHAR_CLASS,
	mxVOID_CLASS,
	mxDOUBLE_CLASS,
	mxSINGLE_CLASS,
	mxINT8_CLASS,
	mxUINT8_CLASS,
	mxINT16_CLASS,
	mxUINT16_CLASS,
	mxINT32_CLASS,
	mxUINT32_CLASS,
	mxINT64_CLASS,
	mxUINT64_CLASS,
	mxFUNCTION_CLASS,
        mxOPAQUE_CLASS,
	mxOBJECT_CLASS
} mxClassID;

/* VERY TEMPORARY AND NASTY HACK TILL mxSPARSE_CLASS IS COMPLETELY ELIMINATED */



# 198 "C:\MATLAB71\extern\include\matrix.h"
typedef enum {
    mxREAL,
    mxCOMPLEX
} mxComplexity;


/* ARRAY_ACCESS_INLINING */


/*
 * Return the class (catergory) of data that the array holds.
 */

# 253 "C:\MATLAB71\extern\include\matrix.h"
extern mxClassID mxGetClassID(const mxArray *pa);



/*
 * Get pointer to data
 */

# 264 "C:\MATLAB71\extern\include\matrix.h"
extern void *mxGetData(
    const mxArray *pa		/* pointer to array */
    );



/* defined(ARRAY_ACCESS_INLINING) */


/*
 * Set pointer to data
 */

# 282 "C:\MATLAB71\extern\include\matrix.h"
extern void mxSetData(
    mxArray *pa,		/* pointer to array */
    void  *newdata		/* pointer to data */
    );



/* 
 * Determine whether the specified array contains numeric (as opposed 
 * to cell or struct) data.
 */

# 297 "C:\MATLAB71\extern\include\matrix.h"
extern bool mxIsNumeric(const mxArray *pa);



/* 
 * Determine whether the given array is a cell array.
 */

# 308 "C:\MATLAB71\extern\include\matrix.h"
extern bool mxIsCell(const mxArray *pa);



/*
 * Determine whether the given array's logical flag is on.
 */

# 319 "C:\MATLAB71\extern\include\matrix.h"
extern bool mxIsLogical(const mxArray *pa);



/*  
 * Determine whether the given array contains character data. 
 */

# 330 "C:\MATLAB71\extern\include\matrix.h"
extern bool mxIsChar(const mxArray *pa);



/*
 * Determine whether the given array is a structure array.
 */

# 341 "C:\MATLAB71\extern\include\matrix.h"
extern bool mxIsStruct(const mxArray *pa);



/*
 * Determine whether the given array is an opaque array.
 */

# 352 "C:\MATLAB71\extern\include\matrix.h"
extern bool mxIsOpaque(const mxArray *pa);



/*
 * Returns true if specified array is a function object.
 */

# 363 "C:\MATLAB71\extern\include\matrix.h"
extern bool mxIsFunctionHandle(const mxArray *pa);



/*
 * Is array user defined object
 */

# 374 "C:\MATLAB71\extern\include\matrix.h"
extern bool mxIsObject(
    const mxArray *pa		/* pointer to array */
    );



/*
 * Get imaginary data pointer for numeric array
 */

# 387 "C:\MATLAB71\extern\include\matrix.h"
extern void *mxGetImagData(
    const mxArray *pa		/* pointer to array */
    );



/* defined(ARRAY_ACCESS_INLINING) */


/*
 * Set imaginary data pointer for numeric array
 */

# 405 "C:\MATLAB71\extern\include\matrix.h"
extern void mxSetImagData(
    mxArray *pa,		/* pointer to array */
    void    *newdata		/* imaginary data array pointer */
    );



/*
 * Determine whether the given array contains complex data.
 */

# 419 "C:\MATLAB71\extern\include\matrix.h"
extern bool mxIsComplex(const mxArray *pa);



/*
 * Determine whether the given array is a sparse (as opposed to full). 
 */

# 430 "C:\MATLAB71\extern\include\matrix.h"
extern bool mxIsSparse(const mxArray *pa);



/*
 * Determine whether the specified array represents its data as 
 * double-precision floating-point numbers.
 */

# 442 "C:\MATLAB71\extern\include\matrix.h"
extern bool mxIsDouble(const mxArray *pa);



/*
 * Determine whether the specified array represents its data as 
 * single-precision floating-point numbers.
 */

# 454 "C:\MATLAB71\extern\include\matrix.h"
extern bool mxIsSingle(const mxArray *pa);



/*
 * Determine whether the specified array represents its data as 
 * signed 8-bit integers.
 */

# 466 "C:\MATLAB71\extern\include\matrix.h"
extern bool mxIsInt8(const mxArray *pa);



/*
 * Determine whether the specified array represents its data as 
 * unsigned 8-bit integers.
 */

# 478 "C:\MATLAB71\extern\include\matrix.h"
extern bool mxIsUint8(const mxArray *pa);



/*
 * Determine whether the specified array represents its data as 
 * signed 16-bit integers.
 */

# 490 "C:\MATLAB71\extern\include\matrix.h"
extern bool mxIsInt16(const mxArray *pa);



/*
 * Determine whether the specified array represents its data as 
 * unsigned 16-bit integers.
 */

# 502 "C:\MATLAB71\extern\include\matrix.h"
extern bool mxIsUint16(const mxArray *pa);



/*
 * Determine whether the specified array represents its data as 
 * signed 32-bit integers.
 */

# 514 "C:\MATLAB71\extern\include\matrix.h"
extern bool mxIsInt32(const mxArray *pa);



/*
 * Determine whether the specified array represents its data as 
 * unsigned 32-bit integers.
 */

# 526 "C:\MATLAB71\extern\include\matrix.h"
extern bool mxIsUint32(const mxArray *pa);



/*
 * Determine whether the specified array represents its data as 
 * signed 64-bit integers.
 */

# 538 "C:\MATLAB71\extern\include\matrix.h"
extern bool mxIsInt64(const mxArray *pa);



/*
 * Determine whether the specified array represents its data as 
 * unsigned 64-bit integers.
 */

# 550 "C:\MATLAB71\extern\include\matrix.h"
extern bool mxIsUint64(const mxArray *pa);



/*
 * Get number of dimensions in array
 */

# 561 "C:\MATLAB71\extern\include\matrix.h"
extern int mxGetNumberOfDimensions(
    const mxArray *pa		/* pointer to array */
    );



/* defined(ARRAY_ACCESS_INLINING) */


/*
 * Get pointer to dimension array
 */

# 579 "C:\MATLAB71\extern\include\matrix.h"
extern const int *mxGetDimensions(
    const mxArray *pa		/* pointer to array */
    );



/* 
 * Get number of elements in array
 */

# 592 "C:\MATLAB71\extern\include\matrix.h"
extern int mxGetNumberOfElements(
    const mxArray *pa		/* pointer to array */
    );



/*
 * Get real data pointer for numeric array
 */

# 605 "C:\MATLAB71\extern\include\matrix.h"
extern double *mxGetPr(
    const mxArray *pa		/* pointer to array */
    );



/* defined(ARRAY_ACCESS_INLINING) */


/*
 * Set real data pointer for numeric array
 */

# 623 "C:\MATLAB71\extern\include\matrix.h"
extern void mxSetPr(
    mxArray *pa,		/* pointer to array */
    double  *pr			/* real data array pointer */
    );



/*
 * Get imaginary data pointer for numeric array
 */

# 637 "C:\MATLAB71\extern\include\matrix.h"
extern double *mxGetPi(
    const mxArray *pa		/* pointer to array */
    );



/* defined(ARRAY_ACCESS_INLINING) */


/*
 * Set imaginary data pointer for numeric array
 */

# 655 "C:\MATLAB71\extern\include\matrix.h"
extern void mxSetPi(
    mxArray *pa,		/* pointer to array */
    double  *pi			/* imaginary data array pointer */
    );



/*
 * Get string array data
 */

# 669 "C:\MATLAB71\extern\include\matrix.h"
extern mxChar *mxGetChars(
    const mxArray *pa		/* pointer to array */
    );



/* defined(ARRAY_ACCESS_INLINING) */


/*
 * Get 8 bits of user data stored in the mxArray header.  NOTE: This state
 * of these bits are not guaranteed to be preserved after API function
 * calls.
 */

# 689 "C:\MATLAB71\extern\include\matrix.h"
extern int mxGetUserBits(
    const mxArray	*pa		/* pointer to array */
    );



/*
 * Set 8 bits of user data stored in the mxArray header. NOTE: This state
 * of these bits are not guaranteed to be preserved after API function
 * calls.
 */

# 704 "C:\MATLAB71\extern\include\matrix.h"
extern void mxSetUserBits(
	mxArray	*pa,		/* pointer to array */
	int	value
    );






/*
 * Get the real component of the specified array's first data element.
 */

# 725 "C:\MATLAB71\extern\include\matrix.h"
extern double mxGetScalar(const mxArray *pa);



/*
 * Is the isFromGlobalWorkspace bit set?
 */

# 736 "C:\MATLAB71\extern\include\matrix.h"
extern bool mxIsFromGlobalWS(const mxArray *pa);



/*
 * Set the isFromGlobalWorkspace bit.
 */

# 747 "C:\MATLAB71\extern\include\matrix.h"
extern void mxSetFromGlobalWS(mxArray *pa, bool global);



/* 
 * Get row dimension
 */

# 758 "C:\MATLAB71\extern\include\matrix.h"
extern int mxGetM(
    const mxArray *pa		/* pointer to array */
    );



/* 
 * Set row dimension
 */

# 771 "C:\MATLAB71\extern\include\matrix.h"
extern void mxSetM(
    mxArray *pa,		/* pointer to array */
    int     m			/* row dimension */
    );



/* 
 * Get column dimension
 */

# 785 "C:\MATLAB71\extern\include\matrix.h"
extern int mxGetN(
    const mxArray *pa		/* pointer to array */
    );



/*
 * Is array empty
 */

# 798 "C:\MATLAB71\extern\include\matrix.h"
extern bool mxIsEmpty(
    const mxArray *pa		/* pointer to array */
    );



/*
 * Get row data pointer for sparse numeric array
 */

# 811 "C:\MATLAB71\extern\include\matrix.h"
extern int *mxGetIr(
    const mxArray *pa		/* pointer to array */
    );



/*
 * Set row data pointer for numeric array
 */

# 824 "C:\MATLAB71\extern\include\matrix.h"
extern void mxSetIr(
    mxArray *pa,		/* pointer to array */
    int     *newir		/* row data array pointer */
    );



/*
 * Get column data pointer for sparse numeric array
 */

# 838 "C:\MATLAB71\extern\include\matrix.h"
extern int *mxGetJc(
    const mxArray *pa		/* pointer to array */
    );



/*
 * Set column data pointer for numeric array
 */

# 851 "C:\MATLAB71\extern\include\matrix.h"
extern void mxSetJc(
    mxArray *pa,		/* pointer to array */
    int     *newjc		/* column data array pointer */
    );



/*
 * Get maximum nonzero elements for sparse numeric array
 */

# 865 "C:\MATLAB71\extern\include\matrix.h"
extern int mxGetNzmax(
    const mxArray *pa		/* pointer to array */
    );



/*
 * Set maximum nonzero elements for numeric array
 */

# 878 "C:\MATLAB71\extern\include\matrix.h"
extern void mxSetNzmax(
    mxArray *pa,		/* pointer to array */
    int     nzmax		/* maximum nonzero elements */
    );



/*
 * Get array data element size
 */

# 892 "C:\MATLAB71\extern\include\matrix.h"
extern int mxGetElementSize(const mxArray *pa);



/* 
 * Return the offset (in number of elements) from the beginning of 
 * the array to a given subscript.  
 */

# 904 "C:\MATLAB71\extern\include\matrix.h"
extern int mxCalcSingleSubscript(const mxArray *pa, int nsubs, const int *subs);



/*
 * Get number of structure fields in array
 */

# 915 "C:\MATLAB71\extern\include\matrix.h"
extern int mxGetNumberOfFields(
    const mxArray *pa		/* pointer to array */
    );



/*
 * Get a pointer to the specified cell element. 
 */

# 928 "C:\MATLAB71\extern\include\matrix.h"
extern mxArray *mxGetCell(const mxArray *pa, int i);



/*
 * Set an element in a cell array to the specified value.
 */

# 939 "C:\MATLAB71\extern\include\matrix.h"
extern void mxSetCell(mxArray *pa, int i, mxArray *value);



/*
 * Return pointer to the nth field name
 */

# 950 "C:\MATLAB71\extern\include\matrix.h"
extern const char *mxGetFieldNameByNumber(const mxArray *pa, int n);



/*
 * Get the index to the named field.
 */

# 961 "C:\MATLAB71\extern\include\matrix.h"
extern int mxGetFieldNumber(const mxArray *pa, const char *name);



/*
 * Return a pointer to the contents of the named field for 
 * the ith element (zero based).
 */

# 973 "C:\MATLAB71\extern\include\matrix.h"
extern mxArray *mxGetFieldByNumber(const mxArray *pa, int i, int fieldnum);



/*
 * Set pa[i][fieldnum] = value 
 */

# 984 "C:\MATLAB71\extern\include\matrix.h"
extern void mxSetFieldByNumber(mxArray *pa, int i, int fieldnum, mxArray *value);



/*
 * Return a pointer to the contents of the named field for the ith 
 * element (zero based).  Returns NULL on no such field or if the
 * field itself is NULL
 */

# 997 "C:\MATLAB71\extern\include\matrix.h"
extern mxArray *mxGetField(const mxArray *pa, int i, const char *fieldname);



/*
 * Set pa[i]->fieldname = value  
 */

# 1008 "C:\MATLAB71\extern\include\matrix.h"
extern void mxSetField(mxArray *pa, int i, const char *fieldname, mxArray *value);



/* 
 * Return the name of an array's class.  
 */

# 1019 "C:\MATLAB71\extern\include\matrix.h"
extern const char *mxGetClassName(const mxArray *pa);



/*
 * Determine whether an array is a member of the specified class. 
 */

# 1030 "C:\MATLAB71\extern\include\matrix.h"
extern bool mxIsClass(const mxArray *pa, const char *name);



/*
 * Set scalar double flag
 */

# 1041 "C:\MATLAB71\extern\include\matrix.h"
extern void mxSetScalarDoubleFlag(
    mxArray	*pa		/* pointer to array */
    );



/* defined(ARRAY_ACCESS_INLINING) */


/*
 * Clear scalar double flag
 */

# 1059 "C:\MATLAB71\extern\include\matrix.h"
extern void mxClearScalarDoubleFlag(
    mxArray	*pa		/* pointer to array */
    );



/* defined(ARRAY_ACCESS_INLINING) */


/*
 * Is scalar double flag set
 */

# 1077 "C:\MATLAB71\extern\include\matrix.h"
extern bool mxIsScalarDoubleFlagSet(
    const mxArray	*pa		/* pointer to array */
    );



/* defined(ARRAY_ACCESS_INLINING) */


/*
 * Set scalar flag if appropiate (double scalar)
 */

# 1095 "C:\MATLAB71\extern\include\matrix.h"
extern void mxSetScalarDoubleFlagIfAppropiate(
    mxArray *pa		/* pointer to array */
    );



/*
 * Mark data as unshareable
 */

# 1108 "C:\MATLAB71\extern\include\matrix.h"
extern void mxSetDataPrivateFlag(
    mxArray	*pa,		/* pointer to array */
    bool        val
    );



/* defined(ARRAY_ACCESS_INLINING) */


/*
 * Is data unshareable?
 */

# 1127 "C:\MATLAB71\extern\include\matrix.h"
extern bool mxIsDataPrivate(
    const mxArray	*pa		/* pointer to array */
    );



/* defined(ARRAY_ACCESS_INLINING) */






/*
 * Create a numeric matrix and initialize all its data elements to 0.
 */

# 1149 "C:\MATLAB71\extern\include\matrix.h"
extern mxArray *mxCreateNumericMatrix(
	int		m,
	int		n,
	mxClassID	classid,
	int		cmplx_flag
	);



/* 
 * Set column dimension
 */

# 1165 "C:\MATLAB71\extern\include\matrix.h"
extern void mxSetN(mxArray *pa, int n);



/*
 * Set dimension array and number of dimensions.  Returns 0 on success and 1
 * if there was not enough memory available to reallocate the dimensions array.
 */

# 1177 "C:\MATLAB71\extern\include\matrix.h"
extern int mxSetDimensions(mxArray *pa, const int *size, int ndims);



/*
 * mxArray destructor
 */

# 1188 "C:\MATLAB71\extern\include\matrix.h"
extern void mxDestroyArray(mxArray *pa);



/*
 * Create a numeric array and initialize all its data elements to 0.
 *
 * Similar to mxCreateNumericMatrix, in a standalone application, 
 * out-of-memory will mean a NULL pointer is returned.
 */

# 1202 "C:\MATLAB71\extern\include\matrix.h"
extern mxArray *mxCreateNumericArray(int ndim, const int *dims, mxClassID classid, mxComplexity flag);



/*
 * Create an N-Dimensional array to hold string data;
 * initialize all elements to 0.
 */

# 1214 "C:\MATLAB71\extern\include\matrix.h"
extern mxArray *mxCreateCharArray(int ndim, const int *dims);



/*
 * Create a two-dimensional array to hold double-precision
 * floating-point data; initialize each data element to 0.
 */

# 1226 "C:\MATLAB71\extern\include\matrix.h"
extern mxArray *mxCreateDoubleMatrix(int m, int n, mxComplexity flag);



/*
 * Get a properly typed pointer to the elements of a logical array.
 */

# 1237 "C:\MATLAB71\extern\include\matrix.h"
extern mxLogical *mxGetLogicals(const mxArray *pa);



/*
 * Create a logical array and initialize its data elements to false.
 */

# 1248 "C:\MATLAB71\extern\include\matrix.h"
extern mxArray *mxCreateLogicalArray(int ndim, const int *dims);



/*
 * Create a two-dimensional array to hold logical data and
 * initializes each data element to false.
 */

# 1260 "C:\MATLAB71\extern\include\matrix.h"
extern mxArray *mxCreateLogicalMatrix(unsigned int m, unsigned int n);



/*
 * Create a logical scalar mxArray having the specified value.
 */

# 1271 "C:\MATLAB71\extern\include\matrix.h"
extern mxArray *mxCreateLogicalScalar(bool value);



/*
 * Returns true if the logical scalar value is true.
 */

# 1282 "C:\MATLAB71\extern\include\matrix.h"
extern bool mxIsLogicalScalarTrue(const mxArray *pa);



/*
 * Create a double-precision scalar mxArray initialized to the
 * value specified
 */

# 1294 "C:\MATLAB71\extern\include\matrix.h"
extern mxArray *mxCreateDoubleScalar(double value);



/*
 * Create a 2-Dimensional sparse array.
 */

# 1305 "C:\MATLAB71\extern\include\matrix.h"
extern mxArray *mxCreateSparse(int m, int n, int nzmax, mxComplexity flag);



/*
 * Create a 2-D sparse logical array
 */

# 1316 "C:\MATLAB71\extern\include\matrix.h"
extern mxArray *mxCreateSparseLogicalMatrix(int m, int n, int nzmax);



/*
 * Copies characters from a MATLAB array to a char array
 * This function will attempt to perform null termination if it is possible.
 * nChars is the number of bytes in the output buffer
 */

# 1329 "C:\MATLAB71\extern\include\matrix.h"
extern void mxGetNChars(const mxArray *pa, char *buf, int nChars);



/*
 * Converts a string array to a C-style string. The C-style string is in the
 * local codepage encoding. If the conversion for the entire Unicode string
 * cannot fit into the supplied character buffer, then the conversion includes
 * the last whole codepoint that will fit into the buffer. The string is thus
 * truncated at the greatest possible whole codepoint and does not split code-
 * points.
 */

# 1345 "C:\MATLAB71\extern\include\matrix.h"
extern int mxGetString(const mxArray *pa, char *buf, int buflen);



/*
 * Create a NULL terminated C string from an mxArray of type mxCHAR_CLASS
 * Supports multibyte character sets.  The resulting string must be freed
 * with mxFree.  Returns NULL on out of memory or non-character arrays.
 */

# 1358 "C:\MATLAB71\extern\include\matrix.h"
extern char *mxArrayToString(const mxArray *pa);



/*
 * Create a 1-by-n string array initialized to str. The supplied string is
 * presumed to be in the local codepage encoding. The character data format
 * in the mxArray will be UTF-16.
 */

# 1371 "C:\MATLAB71\extern\include\matrix.h"
extern mxArray *mxCreateStringFromNChars(const char *str, int n);



/*
 * Create a 1-by-n string array initialized to null terminated string
 * where n is the length of the string.
 */

# 1383 "C:\MATLAB71\extern\include\matrix.h"
extern mxArray *mxCreateString(const char *str);



/*
 * Create a string array initialized to the strings in str.
 */

# 1394 "C:\MATLAB71\extern\include\matrix.h"
extern mxArray *mxCreateCharMatrixFromStrings(int m, const char **str);



/*
 * Create a 2-Dimensional cell array, with each cell initialized
 * to NULL.
 */

# 1406 "C:\MATLAB71\extern\include\matrix.h"
extern mxArray *mxCreateCellMatrix(int m, int n);



/*
 * Create an N-Dimensional cell array, with each cell initialized
 * to NULL.
 */

# 1418 "C:\MATLAB71\extern\include\matrix.h"
extern mxArray *mxCreateCellArray(int ndim, const int *dims);



/*
 * Create a 2-Dimensional structure array having the specified fields;
 * initialize all values to NULL.
 */

# 1430 "C:\MATLAB71\extern\include\matrix.h"
extern mxArray *mxCreateStructMatrix(int m, int n, int nfields, const char **fieldnames);



/*
 * Create an N-Dimensional structure array having the specified fields;
 * initialize all values to NULL.
 */

# 1442 "C:\MATLAB71\extern\include\matrix.h"
extern mxArray *mxCreateStructArray(int ndim, const int *dims, int nfields,
								const char **fieldnames);



/*
 * Make a deep copy of an array, return a pointer to the copy.
 */

# 1454 "C:\MATLAB71\extern\include\matrix.h"
extern mxArray *mxDuplicateArray(const mxArray *in);



/*
 * Set classname of an unvalidated object array.  It is illegal to
 * call this function on a previously validated object array.
 * Return 0 for success, 1 for failure.
 */

# 1467 "C:\MATLAB71\extern\include\matrix.h"
extern int mxSetClassName(mxArray *pa, const char *classname);



/* 
 * Add a field to a structure array. Returns field number on success or -1
 * if inputs are invalid or an out of memory condition occurs.
 */

# 1479 "C:\MATLAB71\extern\include\matrix.h"
extern int mxAddField(mxArray *pa, const char *fieldname);



/*
 * Remove a field from a structure array.  Does nothing if no such field exists.
 * Does not destroy the field itself.
*/

# 1491 "C:\MATLAB71\extern\include\matrix.h"
extern void mxRemoveField(mxArray *pa, int field);






/*
 * Function for obtaining MATLAB's concept of EPS
 */

# 1511 "C:\MATLAB71\extern\include\matrix.h"
extern double mxGetEps(void);



/*
 * Function for obtaining MATLAB's concept of INF (Used in MEX-File callback).
 */

# 1522 "C:\MATLAB71\extern\include\matrix.h"
extern double mxGetInf(void);



/*
 * Function for obtaining MATLAB's concept of NaN (Used in MEX-File callback).
 */

# 1533 "C:\MATLAB71\extern\include\matrix.h"
extern double mxGetNaN(void);



/*
 * test for finiteness in a machine-independent manner
 */

# 1544 "C:\MATLAB71\extern\include\matrix.h"
extern bool mxIsFinite(
    double x                  /* value to test */
    );



/*
 * test for infinity in a machine-independent manner
 */

# 1557 "C:\MATLAB71\extern\include\matrix.h"
extern bool mxIsInf(
    double x                  /* value to test */
    );



/*
 * test for NaN in a machine-independent manner
 */

# 1570 "C:\MATLAB71\extern\include\matrix.h"
extern bool mxIsNaN(
    double x                  /* value to test */
    );














/* defined(V5_COMPAT) */





/* defined(V5_COMPAT) */



/*
mxAssert(int expression, char *error_message)
---------------------------------------------

  Similar to ANSI C's assert() macro, the mxAssert macro checks the
  value of an assertion, continuing execution only if the assertion
  holds.  If 'expression' evaluates to be true, then the mxAssert does
  nothing.  If, however, 'expression' is false, then mxAssert prints an
  error message to the MATLAB Command Window, consisting of the failed
  assertion's expression, the file name and line number where the failed
  assertion occurred, and the string 'error_message'.  'error_message'
  allows the user to specify a more understandable description of why
  the assertion failed.  (Use an empty string if no extra description
  should follow the failed assertion message.)  After a failed
  assertion, control returns to the MATLAB command line. 

  mxAssertS, (the S for Simple), takes the same inputs as mxAssert.  It 
  does not print the text of the failed assertion, only the file and 
  line where the assertion failed, and the explanatory error_message.

  Note that script MEX will turn off these assertions when building
  optimized MEX-functions, so they should be used for debugging 
  purposes only.
*/













/* $Revision: 1.14.4.1 $ */
/* Prototype _d versions of API functions *//* MATLAB_MEX_FILE */

/* matrix_h */



# 60 "C:\MATLAB71\extern\include\mex.h"
typedef struct mexGlobalTableEntry_Tag
{
    const char *name;             /* The name of the global */
    mxArray    **variable;        /* A pointer to the variable */
} mexGlobalTableEntry, *mexGlobalTable;







# 73 "C:\MATLAB71\extern\include\mex.h"
typedef struct mexFunctionTableEntry_tag {
  const char *  name;
  mxFunctionPtr f;
  int           nargin;
  int           nargout;
  struct _mexLocalFunctionTable *local_function_table;
} mexFunctionTableEntry, *mexFunctionTable;

typedef struct _mexLocalFunctionTable {
  size_t           length;
  mexFunctionTable entries;
} _mexLocalFunctionTable, *mexLocalFunctionTable;

typedef struct {
  void (*initialize)(void);
  void (*terminate)(void);
} _mexInitTermTableEntry, *mexInitTermTableEntry;




# 93 "C:\MATLAB71\extern\include\mex.h"
typedef struct {
  int                   version;
  int                   file_function_table_length;
  mexFunctionTable      file_function_table;
  int                   global_variable_table_length;
  mexGlobalTable        global_variable_table;
  int                   npaths;
  const char **         paths;
  int                   init_term_table_length;
  mexInitTermTableEntry init_term_table;
} _mex_information, *mex_information;

typedef mex_information(*fn_mex_file)(void);

typedef void (*fn_clean_up_after_error)(void);
typedef const char *(*fn_simple_function_to_string)(mxFunctionPtr f);

typedef void (*fn_mex_enter_mex_library)(mex_information x);
typedef fn_mex_enter_mex_library fn_mex_exit_mex_library;

typedef mexLocalFunctionTable (*fn_mex_get_local_function_table)(void);
typedef mexLocalFunctionTable (*fn_mex_set_local_function_table)(mexLocalFunctionTable);




/*
 * This header file "mex.h" declares all the types, macros and
 * functions necessary to interface mex files with the current
 * version of MATLAB.  See the release notes for information on 
 * supporting syntax from earlier versions.
 */







/*
 * mexFunction is the user defined C routine which is called upon invocation
 * of a mex function.
 */

# 138 "C:\MATLAB71\extern\include\mex.h"
void mexFunction(
    int           nlhs,           /* number of expected outputs */
    mxArray       *plhs[],        /* array of pointers to output arguments */
    int           nrhs,           /* number of inputs */
    const mxArray *prhs[]         /* array of pointers to input arguments */
);



/*
 * Issue error message and return to MATLAB prompt
 */

# 154 "C:\MATLAB71\extern\include\mex.h"
extern void mexErrMsgTxt(
    const char	*error_msg	/* string with error message */
    );



/*
 * Issue formatted error message with corresponding error identifier and return to MATLAB
 * prompt.
 */

# 168 "C:\MATLAB71\extern\include\mex.h"
extern void mexErrMsgIdAndTxt(
    const char * identifier, /* string with error message identifier */
    const char * err_msg,    /* string with error message printf-style format */
    ...                      /* any additional arguments */
    );



/*
 * Invoke an unidentified warning. Such warnings can only be affected by the M-code
 * 'warning * all', since they have no specific identifier. See also mexWarnMsgIdAndTxt.
 */

# 184 "C:\MATLAB71\extern\include\mex.h"
extern void mexWarnMsgTxt(
    const char	*warn_msg	/* string with warning message */
    );



/*
 * Invoke a warning with message identifier 'identifier' and message derived from 'fmt' and
 * subsequent arguments. The warning may either get printed as is (if it is set to 'on'), or
 * not actually get printed (if set to 'off'). See 'help warning' in MATLAB for more
 * details.
 */

# 200 "C:\MATLAB71\extern\include\mex.h"
extern void mexWarnMsgIdAndTxt(
    const char * identifier,    /* string with warning message identifer */
    const char * warn_msg,	/* string with warning message printf-style format */
    ...                         /* any additional arguments */
    );



/*
 * mex equivalent to MATLAB's "disp" function
 */

# 215 "C:\MATLAB71\extern\include\mex.h"
extern int mexPrintf(
    const char	*fmt,	/* printf style format */
    ...				/* any additional arguments */
    );






/*
 * Remove all components of an array plus the array header itself
 * from MATLAB's memory allocation list.  The array will now
 * persist between calls to the mex function.  To destroy this
 * array, you will need to explicitly call mxDestroyArray().
 */

# 235 "C:\MATLAB71\extern\include\mex.h"
extern void mexMakeArrayPersistent(
    mxArray *pa              /* pointer to array */
    );



/*
 * Remove memory previously allocated via mxCalloc from MATLAB's
 * memory allocation list.  To free this memory, you will need to
 * explicitly call mxFree().
 */

# 250 "C:\MATLAB71\extern\include\mex.h"
extern void mexMakeMemoryPersistent(void *ptr);



/*
 * Look up a function and return an opaque handle for use with
 * mexCallMATLABFunction.
 */

# 262 "C:\MATLAB71\extern\include\mex.h"
extern void mexGetFunctionHandle(void);



/*
 * Call a function whose handle was determined by mexGetFunctionHandle.
 */

# 273 "C:\MATLAB71\extern\include\mex.h"
extern void mexCallMATLABFunction(void);



/*
 * Register a function pointer as a MATLAB-callable function.
 */

# 284 "C:\MATLAB71\extern\include\mex.h"
extern void mexRegisterFunction(void);



/*
 * mex equivalent to MATLAB's "set" function
 */

# 295 "C:\MATLAB71\extern\include\mex.h"
extern int mexSet(double handle, const char *property, mxArray *value);



/* API interface which mimics the "get" function */

# 304 "C:\MATLAB71\extern\include\mex.h"
extern const mxArray *mexGet(double handle, const char *property);



/*
 * call MATLAB function
 */

# 315 "C:\MATLAB71\extern\include\mex.h"
extern int mexCallMATLAB(
    int		nlhs,			/* number of expected outputs */
    mxArray	*plhs[],		/* pointer array to outputs */
    int		nrhs,			/* number of inputs */
    mxArray	*prhs[],		/* pointer array to inputs */
    const char	*fcn_name		/* name of function to execute */
    );



/*
 * set or clear mexCallMATLAB trap flag (if set then an error in  
 * mexCallMATLAB is caught and mexCallMATLAB will return a status value, 
 * if not set an error will cause control to revert to MATLAB)
 */

# 334 "C:\MATLAB71\extern\include\mex.h"
extern void mexSetTrapFlag(int flag);



/*
 * Perform in-place subscript assignment.
 */

# 345 "C:\MATLAB71\extern\include\mex.h"
extern void mexSubsAssign(
      mxArray *plhs, /* pointer to lhs, to be modified in-place */
      const mxArray *prhs, /* pointer to rhs */
      const mxArray *subs[], /* array of subscripts for lhs */
      int nsubs     /* number os subscripts */
      );



/*
 * Retrieve a specified subset of an array.
 */

# 361 "C:\MATLAB71\extern\include\mex.h"
extern mxArray *mexSubsReference(
      const mxArray *prhs, /* pointer to rhs */
      const mxArray *subs[], /* array of subscripts for rhs */
      int nsubs /* number of subscripts */
      );



/*
 * Print an assertion-style error message and return control to the
 * MATLAB command line.
 */

# 377 "C:\MATLAB71\extern\include\mex.h"
extern void mexPrintAssertion(
		const char *test,
		const char *fname,
		int linenum,
		const char *message);



/*
 * Tell whether or not a mxArray is in MATLAB's global workspace.
 */

# 392 "C:\MATLAB71\extern\include\mex.h"
extern bool mexIsGlobal(const mxArray *pA);



















/*
 * mexAddFlops is no longer allowed.  
 */






/* defined(V5_COMPAT) */


/*
 * Place a copy of the array value into the specified workspace with the
 * specified name
 */

# 436 "C:\MATLAB71\extern\include\mex.h"
extern int mexPutVariable(
    const char *workspace,
    const char *name,
    const mxArray *parray		/* matrix to copy */
    );



/*
 * return a pointer to the array value with the specified variable
 * name in the specified workspace
 */

# 452 "C:\MATLAB71\extern\include\mex.h"
extern const mxArray *mexGetVariablePtr(
    const char *workspace,
    const char *name		/* name of symbol */
    );



/*
 * return a copy of the array value with the specified variable
 * name in the specified workspace
 */

# 467 "C:\MATLAB71\extern\include\mex.h"
extern mxArray *mexGetVariable(
    const char	*workspace,
    const char  *name                /* name of variable in question */
    );



/*
 * Lock a MEX-function so that it cannot be cleared from memory.
 */

# 481 "C:\MATLAB71\extern\include\mex.h"
extern void mexLock(void);



/*
 * Unlock a locked MEX-function so that it can be cleared from memory.
 */

# 492 "C:\MATLAB71\extern\include\mex.h"
extern void mexUnlock(void);



/*
 * Return true if the MEX-function is currently locked, false otherwise.
 */

# 503 "C:\MATLAB71\extern\include\mex.h"
extern bool mexIsLocked(void);



/*
 * Return the name of a the MEXfunction currently executing.
 */

# 514 "C:\MATLAB71\extern\include\mex.h"
extern const char *mexFunctionName(void);



/*
 * Parse and execute MATLAB syntax in string.  Returns zero if successful,
 * and a non zero value if an error occurs.
 */

# 526 "C:\MATLAB71\extern\include\mex.h"
extern int mexEvalString(
   const char *str	   /* matlab command string */
);



/*
 * Register Mex-file's At-Exit function (accessed via MEX callback)
 */

# 539 "C:\MATLAB71\extern\include\mex.h"
extern int mexAtExit(
    void	(*exit_fcn)(void)
    );






/* Copyright 1996-1999 The MathWorks, Inc. */

/* $Revision: 1.9.4.1 $ */
/* Prototype _d versions of API functions */

/* mex_h */


/*
  function y = resampc(x, type, shift, extmod)
  % RESAMPC	Resampling along the column
  %
  %	y = resampc(x, type, shift, extmod)
  %
  % Input:
  %	x:	image that is extendable along the column direction
  %	type:	either 1 or 2 (1 for shuffering down and 2 for up)
  %	shift:	amount of shifts (typically 1)
  %     extmod: extension mode:
  %		'per' 	periodic
  %		'ref1'	reflect about the edge pixels
  %		'ref2'	reflect, doubling the edge pixels 
  %
  % Output:
  %	y:	resampled image with:
  %		R1 = [1, shift; 0, 1] or R2 = [1, -shift; 0, 1]
*/

# 27 "resampc.c"
void
mexFunction(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
{
    double *x, *px;		/* input matrix and pointer */
    double *y, *py;		/* result matrix and pointer */
    int type;			/* type of resampling */
    int s;			/* amount of shifts */
    char extmod[10];		/* extension mode */

    int i, j, k, m, n;

    /* Parse input */
    if (nrhs < 4)
	mexErrMsgTxt("Not enough input for RESAMPC!");

    x = mxGetPr(prhs[0]);
    m = mxGetM(prhs[0]);
    n = mxGetN(prhs[0]);

    type = (int) mxGetPr(prhs[1])[0];
    if ((type != 1) && (type != 2))
	mexErrMsgTxt("The second input (type) must be either 1 or 2");

    s = (int) mxGetPr(prhs[2])[0];

    if (!mxIsChar(prhs[3]))
	mexErrMsgTxt("EXTMOD arg must be a string");

    mxGetString(prhs[3], extmod, 10);

    /* Create output */
    plhs[0] = mxCreateDoubleMatrix(m, n, mxREAL);
    y = mxGetPr(plhs[0]);

    px = x;
    py = y;

    if (strcmp(extmod, "per") == 0)
    {
	/* Resampling column-wise:
	 * 		y[i, j] = x[<i+sj>, j] 	if type == 1
	 * 		y[i, j] = x[<i-sj>, j] 	if type == 2
	 */


# 71 "resampc.c"
	for (j = 0; j < n; j++)
	{
	    /* Circular shift in each column */
	    if (type == 1)
		k = (s * j) % m;
	    else
		k = (-s * j) % m;

	    /* Convert to non-negative mod if needed */
	    if (k < 0)
		k += m;

	    for (i = 0; i < m; i++)
	    {
		if (k >= m)
		    k -= m;

		py[i] = px[k];

		k++;
	    }

	    px += m;
	    py += m;
	}
    }

    else
	mexErrMsgTxt("Invalid EXTMOD");
}
